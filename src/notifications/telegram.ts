import TelegramBot from 'node-telegram-bot-api';
import { config } from '../config';
import { ProjectIdea, DailyReport, BuildSpecification } from '../types';
import { MemeTrend } from '../services/memeTrends';
import { AIAgentIdea } from '../analysis/aiAgentGenerator';

let bot: TelegramBot | null = null;

/**
 * Initialize the Telegram bot
 */
export function initTelegramBot(): TelegramBot {
    if (!config.telegram.botToken) {
        throw new Error('TELEGRAM_BOT_TOKEN is not set');
    }

    bot = new TelegramBot(config.telegram.botToken, { polling: false });
    console.log('âœ… Telegram bot initialized');
    return bot;
}

/**
 * Send the daily report to Telegram
 */
export async function sendDailyReport(report: DailyReport): Promise<void> {
    if (!bot) {
        bot = initTelegramBot();
    }

    const chatId = config.telegram.chatId;
    if (!chatId) {
        throw new Error('TELEGRAM_CHAT_ID is not set');
    }

    // Send header message
    const headerMessage = formatHeader(report);
    await bot.sendMessage(chatId, headerMessage, { parse_mode: 'Markdown' });

    // Send each idea as a separate message for better readability
    for (const idea of report.ideas) {
        const ideaMessage = formatIdea(idea);
        await bot.sendMessage(chatId, ideaMessage, { parse_mode: 'Markdown' });
        // Small delay to avoid rate limiting
        await sleep(500);
    }

    // Send footer with market summary
    const footerMessage = formatFooter(report);
    await bot.sendMessage(chatId, footerMessage, { parse_mode: 'Markdown' });

    console.log(`âœ… Sent ${report.ideas.length} ideas to Telegram`);
}

/**
 * Format the header message
 */
function formatHeader(report: DailyReport): string {
    return `
ğŸš€ *CRYPTO AI DAILY REPORT*
ğŸ“… ${report.date}

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
ğŸ“Š *Today's Top ${report.ideas.length} Ideas*
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
`;
}

/**
 * Format a single project idea
 */
function formatIdea(idea: ProjectIdea): string {
    const scoreEmoji = getScoreEmoji(idea.score);
    const simplicityEmoji = idea.launchSimplicity === 'Easy' ? 'ğŸŸ¢' : idea.launchSimplicity === 'Medium' ? 'ğŸŸ¡' : 'ğŸ”´';

    return `
ğŸ”¹ *IDEA #${idea.id}: ${idea.name}*
ğŸ’ Ticker: \`$${idea.ticker}\`
${scoreEmoji} Score: ${idea.score}/10

ğŸ“ *Narrative:*
${idea.narrative}

ğŸ’¡ *Concept:*
${idea.concept}

â° *Why Now:*
${idea.whyNow}

ğŸ¯ *Token Utility:*
${idea.tokenUtility}

${simplicityEmoji} *Launch Simplicity:* ${idea.launchSimplicity}

ğŸ¦ *Twitter Hook:*
_${idea.twitterHook}_

ğŸ“Œ Sources: ${idea.sources.join(', ')}

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
`;
}

/**
 * Format the footer message
 */
function formatFooter(report: DailyReport): string {
    const topTokens = report.marketSnapshot.trendingTokens
        .slice(0, 5)
        .map((t) => `â€¢ ${t.symbol}: ${t.priceChange24h > 0 ? '+' : ''}${t.priceChange24h.toFixed(1)}%`)
        .join('\n');

    const hotTopics = report.marketSnapshot.hotTopics
        .slice(0, 5)
        .map((t) => `â€¢ ${t.keyword} (${t.sentiment})`)
        .join('\n');

    return `
ğŸ“ˆ *MARKET SNAPSHOT*

*Trending Tokens:*
${topTokens || 'â€¢ No data available'}

*Hot Topics on X:*
${hotTopics || 'â€¢ No data available'}

*AI Agent Trends:*
${report.marketSnapshot.aiAgentTrends.slice(0, 3).map((t) => `â€¢ ${t}`).join('\n') || 'â€¢ No data available'}

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
ğŸ¤– Generated by Crypto AI Automation
â° ${report.generatedAt.toISOString()}
`;
}

/**
 * Get emoji based on score
 */
function getScoreEmoji(score: number): string {
    if (score >= 8) return 'ğŸ”¥';
    if (score >= 6) return 'â­';
    if (score >= 4) return 'ğŸ’«';
    return 'ğŸ’­';
}

/**
 * Send a simple text message
 */
export async function sendMessage(text: string): Promise<void> {
    if (!bot) {
        bot = initTelegramBot();
    }

    const chatId = config.telegram.chatId;
    if (!chatId) {
        throw new Error('TELEGRAM_CHAT_ID is not set');
    }

    await bot.sendMessage(chatId, text, { parse_mode: 'Markdown' });
}

/**
 * Send an error notification
 */
export async function sendError(error: string): Promise<void> {
    try {
        await sendMessage(`âš ï¸ *Error in Crypto AI Automation*\n\n${error}`);
    } catch (e) {
        console.error('Failed to send error notification:', e);
    }
}

// Helper
function sleep(ms: number): Promise<void> {
    return new Promise((resolve) => setTimeout(resolve, ms));
}

/**
 * Send meme trends to Telegram
 */
export async function sendMemeTrends(trends: MemeTrend[]): Promise<void> {
    if (!bot) {
        bot = initTelegramBot();
    }

    const chatId = config.telegram.chatId;
    if (!chatId) {
        throw new Error('TELEGRAM_CHAT_ID is not set');
    }

    const header = `
ğŸ­ *VIRAL MEME TRENDS*
ğŸ“… ${new Date().toLocaleDateString('en-US', { weekday: 'long', month: 'long', day: 'numeric' })}

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
ğŸ”¥ *Hot Trends for Meme-Making*
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
`;

    await bot.sendMessage(chatId, header, { parse_mode: 'Markdown' });
    await sleep(300);

    for (const trend of trends) {
        const viralEmoji = trend.virality === 'Exploding' ? 'ğŸ’¥' : trend.virality === 'Hot' ? 'ğŸ”¥' : 'ğŸ“ˆ';
        const platformEmoji = trend.platform === 'X' ? 'ğŸ¦' : trend.platform === 'TikTok' ? 'ğŸ“±' : 'ğŸŒ';

        const trendMessage = `
${viralEmoji} *${trend.name}*
${platformEmoji} Platform: ${trend.platform}

ğŸ“ *What it is:*
${trend.description}

ğŸ’¡ *Meme Idea:*
_${trend.memeIdea}_

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
`;
        await bot.sendMessage(chatId, trendMessage, { parse_mode: 'Markdown' });
        await sleep(300);
    }

    const footer = `
ğŸ¨ *CRYPTO MEME IDEAS*

â€¢ ğŸ• *$CHILL* - Chill Guy unbothered by red candles
â€¢ ğŸ¦ *$PRAWN* - High cortisol degen trader vibes  
â€¢ ğŸ¦ *$GORILLA* - 100 Rugs vs 1 Diamond Hand
â€¢ ğŸ˜®â€ğŸ’¨ *$BURNOUT* - End of year exhaustion token
â€¢ ğŸ„ *$XMAS* - Holiday chaos memecoin

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
ğŸ¤– Pick one and make it viral!
`;

    await bot.sendMessage(chatId, footer, { parse_mode: 'Markdown' });
    console.log(`âœ… Sent ${trends.length} meme trends to Telegram`);
}

/**
 * Send AI Agent ideas with 7-section format to Telegram
 * Enhanced: Senior Architect + Junior Developer Mentor style
 */
export async function sendAIAgentIdeas(ideas: AIAgentIdea[]): Promise<void> {
    if (!bot) {
        bot = initTelegramBot();
    }

    const chatId = config.telegram.chatId;
    if (!chatId) {
        throw new Error('TELEGRAM_CHAT_ID is not set');
    }

    // Send header
    const header = `
ğŸ¤– *CRYPTO PROJECT IDEAS*
ğŸ“… ${new Date().toLocaleDateString('en-US', { weekday: 'long', month: 'long', day: 'numeric', year: 'numeric' })}

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
ğŸ—ï¸ *${ideas.length} Production-Ready Ideas*
_Senior Architect + Junior Mentor Format_
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
`;

    await bot.sendMessage(chatId, header, { parse_mode: 'Markdown' });
    await sleep(300);

    // Send each idea with 7-section format
    for (const idea of ideas) {
        const scoreEmoji = idea.score >= 8 ? 'ğŸ”¥' : idea.score >= 7 ? 'â­' : 'ğŸ’«';

        // Get type emoji
        const getTypeEmoji = (type: string) => {
            switch (type) {
                case 'AI Agent': return 'ğŸ¤–';
                case 'Real Project': return 'ğŸ’¡';
                case 'Gaming': return 'ğŸ®';
                case 'DeFi': return 'ğŸ’°';
                case 'Privacy': return 'ğŸ”’';
                case 'Launchpad': return 'ğŸš€';
                default: return 'âœ¨';
            }
        };
        const typeEmoji = getTypeEmoji(idea.ideaType);

        // SECTION 1: Header + Problem
        const section1 = `
${typeEmoji} *PROJECT #${idea.id}: ${idea.name}*
ğŸ“‚ ${idea.category} | ğŸ”§ ${idea.projectType}
${scoreEmoji} Score: ${idea.score}/10

â”â” ğŸ“Œ WHAT PROBLEM IT SOLVES â”â”

"${idea.problem}"

${idea.problemSource ? `_Source: ${idea.problemSource}_` : ''}
`;
        await bot.sendMessage(chatId, section1, { parse_mode: 'Markdown' });
        await sleep(200);

        // SECTION 2: Simple Explanation (for beginners)
        if (idea.simpleExplanation) {
            const section2 = `
ğŸ§  *HOW IT WORKS (Simple)*

${idea.simpleExplanation}
`;
            await bot.sendMessage(chatId, section2, { parse_mode: 'Markdown' });
            await sleep(200);
        }

        // SECTION 3: Architecture Diagram (plain text for monospace)
        if (idea.systemArchitecture?.diagram) {
            const section3 = `ğŸ—ï¸ SYSTEM ARCHITECTURE

${idea.systemArchitecture.diagram}`;
            await bot.sendMessage(chatId, section3);
            await sleep(200);
        }

        // SECTION 4: Step-by-Step Build Plan
        if (idea.stepByStepPlan && idea.stepByStepPlan.length > 0) {
            const section4 = `ğŸ“š STEP-BY-STEP BUILD PLAN

${idea.stepByStepPlan.map((step, i) => `${i + 1}. ${step}`).join('\n')}`;

            if (section4.length > 4000) {
                const parts = splitMessage(section4, 4000);
                for (const part of parts) {
                    await bot.sendMessage(chatId, part);
                    await sleep(200);
                }
            } else {
                await bot.sendMessage(chatId, section4);
            }
            await sleep(200);
        }

        // SECTION 5: Tech Stack
        const techStackText = idea.techStack && typeof idea.techStack === 'object'
            ? `â€¢ Frontend: ${idea.techStack.frontend}
â€¢ Backend: ${idea.techStack.backend}
â€¢ Blockchain: ${idea.techStack.blockchain}
â€¢ Database: ${idea.techStack.database}${idea.techStack.additional ? `\nâ€¢ Additional: ${idea.techStack.additional}` : ''}`
            : Array.isArray(idea.techStack)
                ? (idea.techStack as unknown as string[]).join(' | ')
                : 'Next.js, TypeScript, Supabase';

        const section5 = `
ğŸ› ï¸ *TECH STACK*

${techStackText}
`;
        await bot.sendMessage(chatId, section5, { parse_mode: 'Markdown' });
        await sleep(200);

        // SECTION 6: Security Considerations
        if (idea.securityConsiderations && idea.securityConsiderations.length > 0) {
            const section6 = `
ğŸ”’ *SECURITY CONSIDERATIONS*

${idea.securityConsiderations.map(s => `â€¢ ${s}`).join('\n')}
`;
            await bot.sendMessage(chatId, section6, { parse_mode: 'Markdown' });
            await sleep(200);
        }

        // SECTION 7: Future Improvements
        if (idea.futureImprovements && idea.futureImprovements.length > 0) {
            const section7 = `
ğŸš€ *FUTURE ROADMAP*

${idea.futureImprovements.map(f => `â€¢ ${f}`).join('\n')}
`;
            await bot.sendMessage(chatId, section7, { parse_mode: 'Markdown' });
            await sleep(200);
        }

        // FULL BUILD PROMPT (plain text)
        const promptMessage = `ğŸ“‹ FULL BUILD PROMPT FOR: ${idea.name}

${idea.buildPrompt}

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”`;

        if (promptMessage.length > 4000) {
            const parts = splitMessage(promptMessage, 4000);
            for (const part of parts) {
                await bot.sendMessage(chatId, part);
                await sleep(200);
            }
        } else {
            await bot.sendMessage(chatId, promptMessage);
        }

        await sleep(500);
    }

    // Send footer
    const footer = `
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
âœ… *${ideas.length} Project Ideas Delivered!*

ğŸ“‹ *How to Use:*
1. Copy any BUILD PROMPT above
2. Paste into Claude, GPT-4, or Cursor
3. Start building your crypto project!

ğŸ¯ Each idea is production-ready with:
â€¢ Full architecture diagram
â€¢ Step-by-step build plan
â€¢ Security best practices
â€¢ Future roadmap

ğŸ¤– Generated by Crypto AI Automation
_Senior Architect + Junior Mentor Edition_
`;

    await bot.sendMessage(chatId, footer, { parse_mode: 'Markdown' });
    console.log(`âœ… Sent ${ideas.length} project ideas with 7-section format to Telegram`);
}

/**
 * Split long messages into parts
 */
function splitMessage(text: string, maxLength: number): string[] {
    const parts: string[] = [];
    let remaining = text;

    while (remaining.length > 0) {
        if (remaining.length <= maxLength) {
            parts.push(remaining);
            break;
        }

        // Find a good break point
        let breakPoint = remaining.lastIndexOf('\n', maxLength);
        if (breakPoint === -1 || breakPoint < maxLength / 2) {
            breakPoint = maxLength;
        }

        parts.push(remaining.substring(0, breakPoint));
        remaining = remaining.substring(breakPoint);
    }

    return parts;
}

/**
 * Send Build Specifications to Telegram (new enhanced format)
 */
export async function sendBuildSpecifications(specs: BuildSpecification[]): Promise<void> {
    if (!bot) {
        bot = initTelegramBot();
    }

    const chatId = config.telegram.chatId;
    if (!chatId) {
        throw new Error('TELEGRAM_CHAT_ID is not set');
    }

    // Send header
    const header = `
ğŸš€ *BUILD SPECIFICATIONS*
ğŸ“… ${new Date().toLocaleDateString('en-US', { weekday: 'long', month: 'long', day: 'numeric', year: 'numeric' })}

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
ğŸ”§ *${specs.length} Project Specs Generated*
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
`;

    await bot.sendMessage(chatId, header, { parse_mode: 'Markdown' });
    await sleep(300);

    // Send each Build Spec
    for (let i = 0; i < specs.length; i++) {
        const spec = specs[i];
        const scoreEmoji = spec.score >= 80 ? 'ğŸ”¥' : spec.score >= 60 ? 'â­' : 'ğŸ’«';

        // Main spec message
        const specMessage = `
${scoreEmoji} *#${i + 1}: ${spec.projectName}*
ğŸ’ Ticker: \`${spec.ticker}\`
ğŸ“Š Score: ${spec.score}/100

ğŸ’¡ *Concept:*
${spec.concept}

â° *Why Now (Alpha):*
${spec.whyNow}

${spec.marketingHook ? `ğŸ¯ *Marketing Hook:*\n_"${spec.marketingHook}"_\n` : ''}
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
`;
        await bot.sendMessage(chatId, specMessage, { parse_mode: 'Markdown' });
        await sleep(200);

        // Tech Stack message
        const techMessage = `
ğŸ›  *TECH STACK for ${spec.ticker}*

â€¢ *Frontend:* ${spec.techStack.frontend}
â€¢ *Blockchain:* ${spec.techStack.blockchain}
â€¢ *Backend:* ${spec.techStack.backend}
â€¢ *Database:* ${spec.techStack.database}
â€¢ *Wallet:* ${spec.techStack.wallet}
${spec.techStack.dataFetching ? `â€¢ *Data Fetching:* ${spec.techStack.dataFetching}` : ''}
${spec.techStack.realtime ? `â€¢ *Realtime:* ${spec.techStack.realtime}` : ''}

âš™ï¸ *Core Features:*
${spec.coreFeatures.map(f => `â€¢ ${f}`).join('\n')}
`;
        await bot.sendMessage(chatId, techMessage, { parse_mode: 'Markdown' });
        await sleep(200);

        // Database Schema
        if (Object.keys(spec.databaseSchema).length > 0) {
            let schemaText = `ğŸ“‹ *DATABASE SCHEMA for ${spec.ticker}*\n\n`;
            for (const [table, fields] of Object.entries(spec.databaseSchema)) {
                schemaText += `*${table}:*\n\`${fields}\`\n\n`;
            }
            await bot.sendMessage(chatId, schemaText, { parse_mode: 'Markdown' });
            await sleep(200);
        }

        // Smart Contract Requirements
        if (spec.smartContractRequirements.length > 0) {
            const contractText = `
ğŸ“œ *SMART CONTRACT REQUIREMENTS*
${spec.smartContractRequirements.map(r => `â€¢ ${r}`).join('\n')}
`;
            await bot.sendMessage(chatId, contractText, { parse_mode: 'Markdown' });
            await sleep(200);
        }

        // Analysis Logic (if available)
        if (spec.analysisLogic) {
            const analysisText = `
ğŸ¯ *SMART MONEY ANALYSIS LOGIC*
${spec.analysisLogic.smartMoneyFilters?.map(f => `â€¢ ${f}`).join('\n') || ''}
${spec.analysisLogic.signalGeneration ? `\nğŸ“¡ *Signal:* ${spec.analysisLogic.signalGeneration}` : ''}
`;
            await bot.sendMessage(chatId, analysisText, { parse_mode: 'Markdown' });
            await sleep(200);
        }

        // Performance Specs (if available)
        if (spec.performanceSpecs) {
            const perfText = `
âš¡ *PERFORMANCE SPECS*
${spec.performanceSpecs.caching ? `â€¢ *Caching:* ${spec.performanceSpecs.caching}` : ''}
${spec.performanceSpecs.realtime ? `â€¢ *Realtime:* ${spec.performanceSpecs.realtime}` : ''}
${spec.performanceSpecs.rateLimit ? `â€¢ *Rate Limit:* ${spec.performanceSpecs.rateLimit}` : ''}
`;
            await bot.sendMessage(chatId, perfText, { parse_mode: 'Markdown' });
            await sleep(200);
        }

        // Roadmap (plain text to avoid markdown issues)
        const roadmapText = `ğŸ“ ROADMAP for ${spec.ticker}

${spec.roadmap.map((step, idx) => `${idx + 1}. ${step.replace('Step ' + (idx + 1) + ': ', '')}`).join('\n')}

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”`;

        // Split if too long
        if (roadmapText.length > 4000) {
            const parts = splitMessage(roadmapText, 4000);
            for (const part of parts) {
                await bot.sendMessage(chatId, part);
                await sleep(200);
            }
        } else {
            await bot.sendMessage(chatId, roadmapText);
        }

        await sleep(500);
    }

    // Footer
    const footer = `
âœ… *${specs.length} Build Specifications Delivered!*

ğŸ’» Copy and paste these specs to your AI coding assistant to start building!

ğŸ¤– Generated by Crypto AI Automation
â° ${new Date().toISOString()}
`;

    await bot.sendMessage(chatId, footer, { parse_mode: 'Markdown' });
    console.log(`âœ… Sent ${specs.length} Build Specifications to Telegram`);
}

